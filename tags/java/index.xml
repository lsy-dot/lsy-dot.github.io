<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on lsy-dot</title>
    <link>https://lsy-dot.github.io/tags/java/</link>
    <description>Recent content in java on lsy-dot</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 19 Sep 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://lsy-dot.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>java集合</title>
      <link>https://lsy-dot.github.io/posts/java%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lsy-dot.github.io/posts/java%E9%9B%86%E5%90%88/</guid>
      <description>quote 种一棵树最好的时间就是十年前，或者是现在。
参考链接 常见问题 集合的底层实现 一次封装ArrayList:数组LinkedList:双向链表HashMap、HashTable:数组+链表(红黑树)LinkedHashMap:HashMap+双向链表(维护插入顺序)TreeMap:(红黑树)二次封装HashSet:HashMapLinkedHashSet:LinkedHashMapTreeSet:TreeMap </description>
    </item>
    
    <item>
      <title>java基础</title>
      <link>https://lsy-dot.github.io/posts/java%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Thu, 08 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://lsy-dot.github.io/posts/java%E5%9F%BA%E7%A1%80/</guid>
      <description>quote 种一棵树最好的时间就是十年前，或者是现在。
参考链接 java IO流
单例模式安全之反射攻击
Java——反射的意义及优缺点
Java反射机制与安全问题
ArrayList源码扩容机制分析
Java集合篇：HashMap 与 ConcurrentHashMap 原理总结
常见问题 小问题 java基本数据类型 数字 [字节数](取值范围)整数byte [1] (-128 ~ 127)short [2] (-32768 ~ 32767)int [4] (-2147483648 ~ 2147483647)long [8] (-9223372036854775808 ~ 9223372036854775807)浮点数float [4] double [8]字符char [2]布尔boolean [1] JDK，JRE，JVM的关系 JDK包含JRE JRE包含JVM
常见关键字 native 本地方法，用c++实现或者其他语言实现synchronizesynchronize与锁升级1、最初直接加重量级锁，需要在用户态和内核态进行切换，耗费大量资源2、jdk1.6之后采用 无锁-&amp;gt;偏向锁(单个线程)-&amp;gt;轻量级锁(少量线程)-&amp;gt;重量级锁(大量线程) 升级的过程进行优化，使得对于锁的获取释放变得更快。transient 字段不参与序列化volatile 保证可见性，不保证原子性 重载和重写 我的理解：重载就是对于不同的情况写不同的方法。 重写就是具体的实现类对于父类的该方法实现不满意，需要自己在写一个满足于自己要求的方法。重写的要求比重载更加苛刻java中的重载与重写的区别：1、重载发生在本类，重写发生在父类与子类之间；（最明显的区别）2、重载的方法名必须相同，重写的方法名相同且返回值类型必须相同；3、重载的参数列表不同，重写的参数列表必须相同。重载发生在本类,方法名相同,参数列表不同,与返回值无关,只和方法名,参数列表,参数的类型有关.</description>
    </item>
    
  </channel>
</rss>
