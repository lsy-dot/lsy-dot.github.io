<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        :root {
            --accent-color: #FF4D4D;
        }
    </style>

    
    
    
    
    
    

    
    <title>java基础</title>
    <meta name="description" content="关于java学习的一些笔记">
    <meta name="keywords" content='java'>

    <meta property="og:url" content="https://lsy-dot.github.io/posts/java%E5%9F%BA%E7%A1%80/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="java基础">
    <meta property="og:description" content="关于java学习的一些笔记">
    <meta property="og:image" content="../../static/images/image-20220829182427839.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="java基础">
    <meta name="twitter:description" content="关于java学习的一些笔记">
    <meta property="twitter:domain" content="https://lsy-dot.github.io/posts/java%E5%9F%BA%E7%A1%80/">
    <meta property="twitter:url" content="https://lsy-dot.github.io/posts/java%E5%9F%BA%E7%A1%80/">
    <meta name="twitter:image" content="../../static/images/image-20220829182427839.png">

    
    <link rel="canonical" href="https://lsy-dot.github.io/posts/java%E5%9F%BA%E7%A1%80/" />

    <link rel="stylesheet" type="text/css" href="https://lsy-dot.github.io//css/normalize.min.css" media="print" onload="this.media='all'">
    <link rel="stylesheet" type="text/css" href="https://lsy-dot.github.io//css/main.css">
    <link disabled id="dark-theme" rel="stylesheet" href="https://lsy-dot.github.io//css/dark.css">

    <script src="https://lsy-dot.github.io//js/svg-injector.min.js"></script>
    <script src="https://lsy-dot.github.io//js/feather-icons.min.js"></script>
    <script src="https://lsy-dot.github.io//js/main.js"></script>

    
    
</head>
<body>
        <script type="text/javascript">
            
            setThemeByUserPref();
        </script><header class="header">
    <nav class="header-nav">

        
        <div class="avatar">
            <a href="https://lsy-dot.github.io/">
                <img src="https://lsy-dot.github.io/images/8531713.jpg" alt="avatar" />
            </a>
        </div>
        

        <div class="nav-title">
            <a class="nav-brand" href="https://lsy-dot.github.io/">lsy-dot</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://lsy-dot.github.io/posts/"> Posts </a>
            </div>
            
            <div class="nav-link">
                <a href="https://lsy-dot.github.io/tags/"> Tags </a>
            </div>
            
            <div class="nav-link">
                <a href="https://github.com"><span data-feather='github'></span>  </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span id="dark-theme-toggle-screen-reader-target" class="sr-only"></span>
                <a>
                    <span id="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <a>
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://lsy-dot.github.io/posts/"> Posts </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://lsy-dot.github.io/tags/"> Tags </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://github.com"><span data-feather='github'></span>  </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span id="dark-theme-toggle-screen-reader-target" class="sr-only">theme</span>
                    <a>
                        <span id="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>java基础</h1>
        <small role="doc-subtitle">关于java学习的一些笔记</small>
        <p class="post-date">
            September 8, 2022
        </p>

        <ul class="post-tags">
        
            <li class="post-tag"><a href="https://lsy-dot.github.io/tags/java">java</a></li>
        
        </ul>
    </div>

    <div class="post-content">
        <p>
            <h1 id="quote">quote</h1>
<p><strong>种一棵树最好的时间就是十年前，或者是现在。</strong></p>
<h1 id="参考链接">参考链接</h1>
<ul>
<li>
<p><a href="https://www.cnblogs.com/yichunguo/p/11775270.html">java IO流</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/6844904186027458568">单例模式安全之反射攻击</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_36470686/article/details/85015753">Java——反射的意义及优缺点</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/m0_38103658/article/details/105482035">Java反射机制与安全问题</a></p>
</li>
<li>
<p><a href="https://juejin.cn/post/6904591515641708552#heading-13">ArrayList源码扩容机制分析</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/a745233700/article/details/119709104">Java集合篇：HashMap 与 ConcurrentHashMap 原理总结</a></p>
</li>
</ul>
<h1 id="常见问题">常见问题</h1>
<h2 id="小问题">小问题</h2>
<h3 id="java基本数据类型">java基本数据类型</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">数字  [字节数](取值范围)
	整数
		byte [1] (-128 ~ 127)
		short [2] (-32768 ~ 32767)
		int [4] (-2147483648 ~ 2147483647)
		long [8] (-9223372036854775808 ~ 9223372036854775807)
	浮点数
		float [4] 
		double [8]
	字符
		char [2]
	布尔
		boolean [1]
</code></pre><h3 id="jdkjrejvm的关系">JDK，JRE，JVM的关系</h3>
<p>JDK包含JRE JRE包含JVM</p>
<h3 id="常见关键字">常见关键字</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">native 本地方法，用c++实现或者其他语言实现

synchronize
synchronize与锁升级
1、最初直接加重量级锁，需要在用户态和内核态进行切换，耗费大量资源
2、jdk1.6之后
采用 无锁-&gt;偏向锁(单个线程)-&gt;轻量级锁(少量线程)-&gt;重量级锁(大量线程) 
升级的过程进行优化，使得对于锁的获取释放变得更快。

transient 字段不参与序列化
volatile 保证可见性，不保证原子性
</code></pre><h3 id="重载和重写">重载和重写</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">我的理解：
重载就是对于不同的情况写不同的方法。 
重写就是具体的实现类对于父类的该方法实现不满意，
需要自己在写一个满足于自己要求的方法。
重写的要求比重载更加苛刻

java中的重载与重写的区别：
1、重载发生在本类，重写发生在父类与子类之间；（最明显的区别）
2、重载的方法名必须相同，重写的方法名相同且返回值类型必须相同；
3、重载的参数列表不同，重写的参数列表必须相同。

重载发生在本类,方法名相同,参数列表不同,与返回值无关,只和方法名,参数列表,参数的类型有关.

重载（Overload）:首先是位于一个类之中或者其子类中，具有相同的方法名， 
但是方法的参数不同，返回值类型可以相同也可以不同。
（1）：方法名必须相同（最重要的重载特征）
（2）：方法的参数列表一定不一样。
（3）：访问修饰符和返回值类型可以相同也可以不同。
其实简单而言：重载就是对于不同的情况写不同的方法。 
比如，同一个类中，写不同的构造函数用于初始化不同的参数。

重写（Overriding）

重写发生在父类子类之间,比如所有类都是继承与Object类的,Object类中本身就有equals,hashcode,toString方法等.在任意子类中定义了重名和同样的参数列表就构成方法重写.

重写（override）：一般都是表示子类和父类之间的关系，其主要的特征是：方法名相同，参数相同，但是具体的实现不同。
重写的特征：
（1）：方法名必须相同，返回值类型必须相同
（2）：参数列表必须相同
（3）：访问权限不能比父类中被重写的方法的访问权限更低。
例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
（4）：子类和父类在同一个包中，那么子类可以重写父类所有方法，
除了声明为private和final的方法。
（5）：构造方法不能被重写，
简单而言：就是具体的实现类对于父类的该方法实现不满意，
需要自己在写一个满足于自己要求的方法。
</code></pre><h3 id="-vs-equals">== vs equals</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">== 
基本类型：值
对象：引用地址

equals
重写：自定义
未重写：引用地址
</code></pre><h3 id="面向对象">面向对象</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">三大特征
    1、封装
    2、继承
    注意：子类拥有父类的private，但需通过父类方法访问
    3、多态
    父类引用指向子类实例
 好处
 	容易维护
 	容易扩展
 	效率高
 	质量高
</code></pre><h3 id="深拷贝vs浅拷贝">深拷贝vs浅拷贝</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">深拷贝:会在内存中再复制一份对象然后指向它
浅拷贝:对象只拷贝引用
</code></pre><h3 id="string-stringbuffer-stringbuilder">String StringBuffer StringBuilder</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">StringBuilder -----&gt;StringBuffer -----&gt;String (快-----&gt;慢);
StringBuilder线程不安全，没加锁，轻量级。
StringBuffer线程安全
String 用+=每次循环都创建一个StringBuilder
</code></pre><h3 id="异常体系">异常体系</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">throwable
	Error  [OutOfMemoryError,StackOverFlowError]
	Exception
		IoException(checked)[io,class not found]
		RuntimeException(unchecked)[空指针,越界,算术]
		
</code></pre><h3 id="finally">finally</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">finally中的return会优先于try中的return执行
</code></pre><h3 id="代理模式">代理模式</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">静态代理
动态代理
	JDK动态代理
		为什么要实现同一个接口？
		因为代理类和被代理类要建立关系，要么继承要么接口，
		而代理类需要继承Proxy，所以只能接口了
		JDK动态代理类实现InvocationHandler接口
	cglib
		代理类(不可以声明为final)
		因为要通过继承的方式
		原理:定义拦截器
</code></pre><h3 id="java获取class对象的4种方式">java获取class对象的4种方式</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">类名.class
class.forname
实例.getClass
xxxClassloader.loadClass
</code></pre><h3 id="io流api">IO流（API）</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">1、	    字节流、字符流
输入流   字节输入流 InputStream      字符输入流 Reader
输出流   字节输出流 OutputStream     字符输出流 Writer
2、除此之外，还有一些缓冲流会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。
当然，这个数组可以自己设置大小，设置的越大效率越高。
3、转换流   字符和字节之间通过不同的编码方式进行转化
4、序列化流 对象序列化
5、打印流  打印到文件或者控制台。
</code></pre><h3 id="file类常用api">File类常用api</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">创建
	File(File parent, String child)
	File(String pathname)
	File(String parent, String child)
	File(URI uri)
常用api
	exists()
	isDirectory()
	isFile()
	delete()
	mkdir()
	mkdirs()
一般用法是创建file之后传给一个字节流进行后续操作
</code></pre><h3 id="arraylist扩容机制">arraylist扩容机制</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">当我们使用默认的构造器是实例化ArrayList时，数组大小经过种种判断扩容为10。
使用默认构造器实例化的ArrayList，在第一次添加元素和第11次添加元素时才会触发扩容。也就是第一次时，和超过数组容量时添加才触发扩容。
而初始化指定实例化创建的ArrayList只有超过数组容量时添加才触发扩容。扩容为1.5倍左右（分奇偶数）

JDK1.7:ArrayList像饿汉式，直接创建一个初始容量为10的数组
JDK1.8:ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元 素时再创建一个始容量为10的数组
</code></pre><h3 id="java序列化id的作用">java序列化id的作用</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">https://segmentfault.com/a/1190000038315377
判断版本是否一致
默认:根据类里面的字段方法去计算hash值，
指定:不改版本号也是可以反序列化成功的，但是值会变成0
</code></pre><h3 id="try-catch-finally-的return执行顺序">try catch finally 的return执行顺序</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">https://segmentfault.com/a/1190000040313393
try块：用于捕获异常。
	后面可以有0个或多个catch块。
	只能有0个或1个finally块。
	try块后面，如果没有catch块，则后面必须有一个finally块。
	执行代码捕获异常后，进入catch块，try中出现异常代码处后面的代码不会再继续执行。
catch块：用于处理处理try中捕获的异常。
	可以有多个catch块，进入一个catch块后，执行完毕后，如果有finally块，则进入finally块。即使后面还有catch块，也不会再进入其他catch块。
finally块：无论是否捕获或处理异常，finally块中的代码都会被执行。
	当try块中或者catch块中遇到return语句时，先执行完finally里面的代码后，再执行return返回语句。
</code></pre><h3 id="short-a-1aa1-运行结果原理">short a =1;a=a+1 运行结果，原理</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">https://blog.csdn.net/DragonGirI/article/details/81587525
java里a=a+1会自动转型成int，如果不进行显示转换，而是将int强转short就会报错.
隐式类型转换可以从小到大自动转，即byte→short→int→long；如果反过来会丢失精度，必须进行显示类型转换
</code></pre><h3 id="int-和-integer-区别联系">int 和 Integer 区别联系</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">推荐阅读:https://blog.csdn.net/chenliguan/article/details/53888018
基本区别
	[Integer][int]
	[包装类][基本数据类型]
	[存的是引用][存的是数值]
	[默认null][默认0]
深入对比
	两个new的Integer不会相等，但是非new的会相等[存在常量池(-128-127)里面了]
</code></pre><h2 id="问题">问题</h2>
<h3 id="为什么重写equals要重写hashcode">为什么重写equals要重写hashcode</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">这里明确一点，
就是hashcode的应用场景是hashset、hashmap、hashtable这些集合
起到效果是：
object类里面的hashcode默认是基于内存地址的，
但在实际应用中我们一般会想要根据内容来判断是否是重复元素，
所以我们会重写equals，但重写之后如果使用默认的hashcode，
那么对相同内容的对象其hashcode是不同的所以会重复添加，
所以要重写hashcode，重写的方式是根据内容生成hashcode。
</code></pre><h3 id="反射的优缺点以及如何安全防范">反射的优缺点以及如何安全防范</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">优点：动态编译，灵活性高
缺点：性能、安全（拿到private方法和属性）
安全问题如何防范：
1、单例防范：  不能new、枚举
①重构代码以避免使用反射;
②尽量避免使用用户控制的输入来选择和加载类或代码。
</code></pre><h3 id="hashmap-与-concurrenthashmap-原理总结">HashMap 与 ConcurrentHashMap 原理总结</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">hashmap是什么
1、基于Map接口实现，线程不安全，允许key为null，但只能有一个
2、数据结构
jdk7,数组+链表
jdk8,数组+链表+红黑树（链表转换为红黑树是在单个链表长度大于8，数组长度大于64）
3、关键参数
容量:默认16，必须是2的N次幂
加载因子:容量可以达到多满的程度，默认值为 0.75
扩容阈值 threshold = capacity * loadfactor
4、Fail-Fast 机制
多线程修改时根据modCount看修改次数避免多线程，直接抛异常


为什么在长度是8的时候转红黑树
推荐阅读:https://www.jianshu.com/p/fdf3d24fe3e8
官方文档如下
In usages with well-distributed user hashCodes, tree bins 
are rarely used.  Ideally, under random hashCodes, the 
frequency of nodes in bins follows a Poisson distribution 
(http://en.wikipedia.org/wiki/Poisson_distribution) with a 
parameter of about 0.5 on average for the default resizing 
threshold of 0.75, although with a large variance because 
of resizing granularity. Ignoring variance, the expected 
occurrences of list size k are (exp(-0.5) * pow(0.5, k) / 
factorial(k)). The first values are:
 
 0:    0.60653066
 1:    0.30326533
 2:    0.07581633
 3:    0.01263606
 4:    0.00157952
 5:    0.00015795
 6:    0.00001316
 7:    0.00000094
 8:    0.00000006
 more: less than 1 in ten million
 解释一下:
 	如果hashcode设计的很好的话，链表长度的概率如上图
 	长度为8时的概率只有千分之一，也就是说不怎么会出现红黑树
 	但是如果用户自己定义一些垃圾的hashcode算法就没法保障了
 	这也是这个红黑树优化的作用。

HashMap 的 put() 方法添加元素的过程：
1、计算hash值
2、hash和数组长度进行与运算，计算存储的下标
3、添加到数组链表中
	为空，直接添加
	存在链表
		jdk1.7以及之前：头插法
		jdk1.8及之后:尾插法
	判断是否需要红黑树化
	判断是否要扩容
	
HashMap扩容的过程：
1、重建数组，长度为原来的两倍
2、遍历旧数组，重新计算下标，使用节点的hash值与旧数组长度进行位与运算
	为0:位置不变
	否则:原位置+原数组长度
3、转移数据，重新设置扩容阈值

hashmap线程不安全，要线程安全可以用Hashtable（synchronized ）
Hashtable 不允许 null  键和 null 值

ConcurrentHashMap 是什么
1、采用了CAS+synchronized 的hashmap
2、版本区别
	jdk1.7 Segment分段锁 ReentronLock
	jdk1.8	锁数组的下标 synchronized(jdk1.6后的优化性能已经上来了)
	
ConcurrentHashMap 的扩容的过程：
不加锁
1、根据cpu数和数组长度计算每个线程应该处理的桶数量
2、新建两倍长的数组（单线程）
3、转移数据（多线程）
	初始化 ForwardingNode 对象
		占位(表示)
		转发查询到新的数组上(不会阻塞查询操作。)
	从左到由依次迁移当前线程负责的数组
		没有元素，放置ForwardingNode（CAS）
		处理过，跳过
		加synchronized ，转移数据
		设置ForwardingNode
	每一次线程结束，sizeCtl--，
	所有线程结束检查一遍，设置扩容阈值
</code></pre><h3 id="threadlocal">Threadlocal</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">https://www.cnblogs.com/giserliu/p/4205454.html
内存泄漏，结合GC回收，对不再使用的对象进行置空，
比如Threadlocal
每个Thread里有一个ThreadLocalMap
每个ThreadLocalMap里有很多的ThreadLocal
ThreadLocal（类型）是ThreadLocalMap的key，它是弱引用
Object（类型）是ThreadLocalMap的value，它是强引用
使用弱引用的目的
当ThreadLocal不再被需要时，下次GC可以直接回收他
但是对于周期比较长的线程，用完变量之后，要主动调用ThreadLocalMap#remove()主动清理
不然会由于value是强引用出现内存泄漏。
</code></pre><h3 id="jdk18新特性">jdk1.8新特性</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">lambda表达式
	接口default
方法引用
Stream api
localdatetime

https://blog.csdn.net/fanghuainihao/article/details/123682021
</code></pre><h3 id="python和java的区别java有什么优势和劣势">python和Java的区别，Java有什么优势和劣势</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">java的优势
	严谨、健壮、不容易出错
		自动垃圾回收
		抛弃无符号类型
		安全的枚举
		编译期泛型检查
		强制的异常处理
	标准库设计很规范 [用了大量的设计模式]
java的劣势
	代码好多
python的优势
	python语法简单，第三方库很多
	一些都是对象[类也是]
python的劣势
	慢
	动态语言不好重构 [写testcase]
</code></pre><h3 id="idea常用插件">IDEA常用插件</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">推荐阅读：https://developer.aliyun.com/article/803464
操作
	Key Promoter X [IDEA快捷键提示 用快捷键代替鼠标操作]
	Translation [翻译]
格式
	Save Actions [格式自动化]
文档
    Javadoc [Javadoc生成插件]
    Easy Javadoc [Javadoc生成插件]
自动编码
	Codota AI Autocomplete [代码自动提示和推荐]
	Auto filling Java call arguments [自动填充调用方法参数] 
    GenerateAllSetter [自动生成调用对象的set方法]
    GenerateO2O [自动生成对象之前的传输方法]
	Squaretest [自动生成单元测试]
代码分析
	SequenceDiagram [方法调的深度，生产时序图]
    Maven Helper [Maven依赖分析工具]
    FindBugs-IDEA [代码质量扫描检查工具]
    CheckStyle-IDEA [编码风格扫描检查工具]
</code></pre><h1 id="数据结构">数据结构</h1>
<h2 id="二叉树">二叉树</h2>
<h3 id="满二叉树和完全二叉树">满二叉树和完全二叉树</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">https://zhuanlan.zhihu.com/p/152285749
对于满二叉树，除最后一层无任何子节点外，每一层上的所有结点都有两个子结点二叉树。
完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树而引出来的。
就是满二叉树最后一层从左到右没有填满。
</code></pre><h3 id="平衡二叉树有什么应用红黑树">平衡二叉树有什么应用(红黑树)</h3>
<pre tabindex="0"><code class="language-a" data-lang="a">https://segmentfault.com/a/1190000039774810
性质1. 结点是红色或黑色。（why：为什么节点要区分颜色，红色节点的作用是什么？）
性质2. 根结点是黑色。（why：为什么根节点必须是黑色）
性质3. 所有叶子都是黑色。（why）
性质4. 从每个叶子到根的所有路径上不能有两个连续的红色结点。(why)
性质5. 从任一节结点其每个叶子的所有路径都包含相同数目的黑色结点。(why)
性质6. 每次新插入的节点都必须是红色（why）
红黑树最终是为了解决二叉查找树性能退化成链表的问题，
对2-3树的2标记成红色，单节点标记成黑色。
</code></pre>
        </p>
    </div>
</div>

<aside class="post-toc">
    <nav id="toc">
        <nav id="TableOfContents">
  <ul>
    <li><a href="#quote">quote</a></li>
    <li><a href="#参考链接">参考链接</a></li>
    <li><a href="#常见问题">常见问题</a>
      <ul>
        <li><a href="#小问题">小问题</a>
          <ul>
            <li><a href="#java基本数据类型">java基本数据类型</a></li>
            <li><a href="#jdkjrejvm的关系">JDK，JRE，JVM的关系</a></li>
            <li><a href="#常见关键字">常见关键字</a></li>
            <li><a href="#重载和重写">重载和重写</a></li>
            <li><a href="#-vs-equals">== vs equals</a></li>
            <li><a href="#面向对象">面向对象</a></li>
            <li><a href="#深拷贝vs浅拷贝">深拷贝vs浅拷贝</a></li>
            <li><a href="#string-stringbuffer-stringbuilder">String StringBuffer StringBuilder</a></li>
            <li><a href="#异常体系">异常体系</a></li>
            <li><a href="#finally">finally</a></li>
            <li><a href="#代理模式">代理模式</a></li>
            <li><a href="#java获取class对象的4种方式">java获取class对象的4种方式</a></li>
            <li><a href="#io流api">IO流（API）</a></li>
            <li><a href="#file类常用api">File类常用api</a></li>
            <li><a href="#arraylist扩容机制">arraylist扩容机制</a></li>
            <li><a href="#java序列化id的作用">java序列化id的作用</a></li>
            <li><a href="#try-catch-finally-的return执行顺序">try catch finally 的return执行顺序</a></li>
            <li><a href="#short-a-1aa1-运行结果原理">short a =1;a=a+1 运行结果，原理</a></li>
            <li><a href="#int-和-integer-区别联系">int 和 Integer 区别联系</a></li>
          </ul>
        </li>
        <li><a href="#问题">问题</a>
          <ul>
            <li><a href="#为什么重写equals要重写hashcode">为什么重写equals要重写hashcode</a></li>
            <li><a href="#反射的优缺点以及如何安全防范">反射的优缺点以及如何安全防范</a></li>
            <li><a href="#hashmap-与-concurrenthashmap-原理总结">HashMap 与 ConcurrentHashMap 原理总结</a></li>
            <li><a href="#threadlocal">Threadlocal</a></li>
            <li><a href="#jdk18新特性">jdk1.8新特性</a></li>
            <li><a href="#python和java的区别java有什么优势和劣势">python和Java的区别，Java有什么优势和劣势</a></li>
            <li><a href="#idea常用插件">IDEA常用插件</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#数据结构">数据结构</a>
      <ul>
        <li><a href="#二叉树">二叉树</a>
          <ul>
            <li><a href="#满二叉树和完全二叉树">满二叉树和完全二叉树</a></li>
            <li><a href="#平衡二叉树有什么应用红黑树">平衡二叉树有什么应用(红黑树)</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
    </nav>
</aside>



    

        </main><footer class="footer">
    <span>&copy; 2022 lsy-dot</span>
    <span>
        Made with &#10084;&#65039; using <a target="_blank" href="https://github.com/526avijitgupta/gokarna">Gokarna</a>
    </span>
</footer>
</body>
</html>
